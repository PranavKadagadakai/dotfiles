from __future__ import annotations
from celery import shared_task
from django.core.files.base import ContentFile
from django.utils import timezone

@shared_task(bind=True)
def generate_certificates_and_allocate_points(self, event_id):
    """
    Generate certificate files for all participants of an event and optionally
    allocate AICTE points. This implementation is defensive: it checks for
    model/attribute presence and falls back to a minimal placeholder file so
    the DB operations succeed without requiring image/PDF libs.
    """
    try:
        from apps.events.models import Event
        from apps.certificates.models import CertificateTemplate
        from api.models import Certificate as APICertificate  # Certificate DB model used by API
        # Try to import Participant model if available
        try:
            from api.models import Participant
        except Exception:
            Participant = None

        # AICTE points model (optional)
        try:
            from apps.aicte_points.models import AICTEPointTransaction
        except Exception:
            AICTEPointTransaction = None

        event = Event.objects.get(pk=event_id)

        # Try common participant/registration related attributes
        participants_qs = None
        if hasattr(event, "participants"):
            participants_qs = event.participants.all()
        elif hasattr(event, "registrations"):
            participants_qs = event.registrations.all()
        else:
            # As a last resort, try Participants via Participant model
            if Participant is not None:
                participants_qs = Participant.objects.filter(event=event)
            else:
                participants_qs = []

        template = getattr(event, "template", None) or CertificateTemplate.objects.filter(club=getattr(event, "club", None), is_active=True).first()

        created = 0
        errors = []
        for participant in participants_qs:
            try:
                student = getattr(participant, "student", None) or getattr(participant, "student_id", None)
                student_id = getattr(student, "id", student) if student is not None else "unknown"
                filename = f"cert_event_{event.id}_participant_{student_id}.pdf"

                # Create a minimal placeholder PDF-like content to attach
                content = b"%PDF-1.4\n%Placeholder certificate generated by task\n"
                content += f"Event: {getattr(event, 'event_name', getattr(event, 'name', 'Unnamed'))}\n".encode("utf-8")
                content += f"Participant: {getattr(student, 'id', str(student_id))}\n".encode("utf-8")
                content += f"GeneratedAt: {timezone.now().isoformat()}\n".encode("utf-8")

                cert_obj, _ = APICertificate.objects.update_or_create(
                    event=event,
                    participant=participant,
                    defaults={
                        "certificate_file": ContentFile(content, name=filename),
                        "generated_at": timezone.now()
                    }
                )
                created += 1

                # Try to allocate AICTE points if possible and event has a point value
                if AICTEPointTransaction is not None and hasattr(event, "aicte_points") and getattr(event, "aicte_points"):
                    try:
                        student_fk = getattr(participant, "student", None)
                        category = getattr(event, "aicte_category", None)
                        AICTEPointTransaction.objects.create(
                            student=student_fk,
                            event=event,
                            category=category,
                            points_allocated=getattr(event, "aicte_points", 0),
                            transaction_status="PENDING"
                        )
                    except Exception:
                        # non-fatal: continue
                        pass

            except Exception as e:
                errors.append(str(e))
                continue

        # Mark event as finished if field exists
        if hasattr(event, "status"):
            try:
                event.status = getattr(event, "status", "finished") or "finished"
                event.save()
            except Exception:
                pass
        elif hasattr(event, "event_status"):
            try:
                event.event_status = "COMPLETED"
                event.event_ended_at = timezone.now()
                event.save()
            except Exception:
                pass

        return {"created": created, "errors": errors}
    except Exception as exc:
        # Let Celery handle retries if configured
        raise self.retry(exc=exc, countdown=30, max_retries=3)