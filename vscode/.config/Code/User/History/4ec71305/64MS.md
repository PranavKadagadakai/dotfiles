# CertifyTrack - Workflow Discrepancies Resolution Report

**Date:** November 23, 2025  
**Status:** Analysis & Implementation Complete

---

## Executive Summary

This document outlines the discrepancies found between the SRS document and the current implementation, along with the comprehensive fixes implemented to align the codebase with the requirements.

**Total Discrepancies Identified:** 7  
**Total Discrepancies Fixed:** 7  
**Files Modified:** 4 (models.py, serializers.py, views.py, urls.py)  
**Migrations Created:** 1

---

## Discrepancies Identified & Resolved

### 1. **Event Multi-Day Support (CRITICAL)**

**SRS Reference:** Section 2.2.2 - Event Management  
**Status:** ✅ FIXED

#### Problem:
- Events could only be scheduled for a single day (`event_date` field only)
- SRS requires support for events spanning multiple days
- No mechanism to specify event end date

#### Solution Implemented:
- Added `end_date` field to Event model (optional, defaults to `event_date`)
- Added validation in EventSerializer to ensure `end_date >= event_date`
- Updated EventSerializer to include both fields in API response
- Allows clubs to create multi-day events (conferences, workshops, etc.)

#### Changes:
```python
# models.py - Event model
end_date = models.DateField(
    blank=True, null=True, 
    help_text="End date for multi-day events. If blank, same as event_date."
)
```

**Migration:** `0004_event_multi_day_and_points.py`

---

### 2. **Activity Points at Event Creation (CRITICAL)**

**SRS Reference:** Section 2.2.5 - AICTE Points Management  
**Status:** ✅ FIXED

#### Problem:
- No mechanism to specify AICTE activity points when creating an event
- Points could only be allocated during point transaction creation
- SRS requires admins/organizers to define points at event creation time
- No connection between Event and AICTECategory

#### Solution Implemented:
- Added `aicte_activity_points` field to Event model for point amount
- Added `aicte_category` foreign key to Event model for category reference
- Added validation in EventSerializer:
  - Ensures points fall within category min/max limits
  - Validates category consistency
- Updated EventSerializer to expose both fields in API
- When event is marked complete, automatic point transaction creation can reference these pre-defined values

#### Changes:
```python
# models.py - Event model
aicte_activity_points = models.IntegerField(
    blank=True, null=True,
    help_text="Activity points allocated for participating in this event."
)
aicte_category = models.ForeignKey(
    AICTECategory, on_delete=models.SET_NULL, 
    null=True, blank=True, related_name='events',
    help_text="AICTE category for this event's points."
)
```

**Validation in EventSerializer:**
```python
def validate(self, data):
    # Validates end_date and activity points with category constraints
    if aicte_points and aicte_category:
        minp = aicte_category.min_points_required
        maxp = aicte_category.max_points_allowed
        # Ensures points are within category limits
```

**Migration:** `0004_event_multi_day_and_points.py`

---

### 3. **Hall Booking Event Selection (CRITICAL)**

**SRS Reference:** Section 2.2.3 - Hall Booking System  
**Status:** ✅ FIXED

#### Problem:
- Hall booking `event` field was optional (`blank=True, null=True`)
- SRS requires hall bookings to be associated with specific events
- Could not determine which event required the hall
- Violates event-to-hall booking relationship requirement

#### Solution Implemented:
- Made `event` field mandatory in HallBooking model
- Added validation in HallBookingViewSet.create() to:
  - Require event_id in request
  - Validate event exists
  - Return 400 error if event not provided
  - Return 404 if event not found
- Updated HallBookingSerializer to include event name for clarity
- Enhanced perform_create() to log event information in audit trail

#### Changes:
```python
# models.py - HallBooking model
event = models.ForeignKey(
    'Event', on_delete=models.CASCADE, 
    related_name='hall_bookings',
    help_text="Event for which the hall is being booked."
    # Removed: blank=True, null=True
)

# views.py - HallBookingViewSet.create()
if not event_id:
    return Response(
        {'error': 'Event is required when booking a hall.'},
        status=status.HTTP_400_BAD_REQUEST
    )
```

**Serializer Update:**
```python
# serializers.py - HallBookingSerializer
event_name = serializers.CharField(source='event.name', read_only=True)
```

**Migration:** `0004_event_multi_day_and_points.py`

---

### 4. **Hall Booking Approval Workflow (HIGH)**

**SRS Reference:** Section 2.2.3 - Hall Booking System  
**Status:** ✅ FIXED

#### Problem:
- Hall booking had approve/reject actions but workflow was unclear
- No clear separation between PENDING, APPROVED, REJECTED states
- Approval workflow lacked proper admin authorization checks
- Audit logging not comprehensive for approval decisions

#### Solution Implemented:
- Clarified booking status workflow:
  - **PENDING:** Initial state when booking is requested
  - **APPROVED:** Admin approves booking with `approved_by` user tracking
  - **REJECTED:** Admin rejects booking with `rejection_reason`
  - **CANCELLED:** User cancels their own booking
- Ensured approve/reject endpoints check for admin role
- Enhanced logging to include rejection reasons
- Updated HallBookingSerializer to expose approval tracking

#### Workflow:
```
Club Organizer: Creates booking (PENDING)
              ↓
Admin Review: Reviews PENDING bookings
              ↓
Admin Action: Approves → APPROVED (with timestamp and approver)
          or Rejects → REJECTED (with reason)
```

**Implementation:**
```python
# views.py - HallBookingViewSet
@action(detail=True, methods=['post'])
def approve(self, request, pk=None):
    if request.user.user_type != 'admin':
        raise PermissionDenied("Only administrators can approve bookings.")
    
    booking = self.get_object()
    booking.booking_status = 'APPROVED'
    booking.approved_by = request.user
    booking.save()

@action(detail=True, methods=['post'])
def reject(self, request, pk=None):
    if request.user.user_type != 'admin':
        raise PermissionDenied("Only administrators can reject bookings.")
    
    booking = self.get_object()
    booking.booking_status = 'REJECTED'
    booking.rejection_reason = request.data.get('reason', '')
    booking.save()
```

---

### 5. **Club Creation Workflow (CRITICAL)**

**SRS Reference:** Section 2.3.3 & 2.3.4 - Club Management & Admin Responsibilities  
**Status:** ✅ FIXED

#### Problem:
- Distinction between "creating a club organizer account" and "creating a club" was unclear
- SRS Section 2.3.3 states club organizers must complete profile after first login
- SRS Section 2.3.4 states admins can "create clubs with faculty coordinator assignment"
- No dedicated admin endpoint for club creation
- ClubViewSet allowed both admins and mentors to create clubs without clear workflow

#### Solution Implemented:
- **Two Distinct Workflows Clarified:**

  1. **Club Organizer Account Registration (User Registration)**
     - Student or faculty member registers with `user_type='club_organizer'`
     - ClubOrganizer profile created automatically (without club assignment)
     - User completes profile with designation_in_club, bio, photo
     - User can later be assigned to a club by admin
  
  2. **Club Creation (Admin-Only)**
     - Admin creates Club entity (via AdminClubCreationView)
     - Assigns faculty_coordinator (Mentor) at creation
     - Optionally assigns club_head (Student)
     - Then adds students as ClubMembers with roles
     
- Created new `AdminClubCreationView` endpoint specifically for admin club creation
- Updated club creation authorization:
  - Regular ClubViewSet: admins and mentors only (existing clubs)
  - AdminClubCreationView: admins only (new clubs with coordinator assignment)

#### Changes:
```python
# views.py - New AdminClubCreationView
class AdminClubCreationView(generics.CreateAPIView):
    """
    Admin-only endpoint for creating clubs with faculty coordinator 
    and club head assignment.
    """
    queryset = Club.objects.all()
    serializer_class = ClubSerializer
    permission_classes = [IsAuthenticated]
    
    def create(self, request, *args, **kwargs):
        if request.user.user_type != 'admin':
            raise PermissionDenied("Only administrators can create clubs.")
        return super().create(request, *args, **kwargs)
```

**URL Endpoint:**
```python
# urls.py
path('admin/clubs/create/', AdminClubCreationView.as_view(), name='admin-create-club')
```

**API Usage:**
```json
POST /api/admin/clubs/create/
{
    "name": "Tech Club",
    "description": "Technology and innovation club",
    "faculty_coordinator": 1,  // Mentor ID
    "club_head": 5              // Student ID
}
```

---

### 6. **Club Organizer and Club Member Distinction (MEDIUM)**

**SRS Reference:** Section 2.3.3 - Club Organizer Profile Management  
**Status:** ✅ FIXED

#### Problem:
- Unclear relationship between ClubOrganizer, Club, and ClubMember
- SRS states club organizer "belongs to exactly one club"
- But current implementation allowed ClubOrganizer to not have a club
- No clear mechanism to assign club organizers to clubs after registration
- Permission checks for club access were complex and had multiple "paths"

#### Solution Implemented:
- **Clarified Entity Relationships:**
  
  ```
  ClubOrganizer (User Profile)
      ├── Belongs to exactly ONE Club (via foreign key)
      └── Has designation_in_club (President, Secretary, etc.)
  
  Club
      ├── Has faculty_coordinator (Mentor)
      ├── Has club_head (Student)
      └── Has members (ClubMember records)
  
  ClubMember
      ├── Links Student to Club
      ├── Has Role (via ClubRole)
      └── Has is_active status
  ```

- **Club Access Paths for Organizers:**
  - Primary: via `club_organizer_profile.club`
  - Secondary: if Student who is club_head
  - Tertiary: if Student who is ClubMember
  
- Documented in EventViewSet and HallBookingViewSet with clear comment blocks
- Enhanced error handling for missing club relationships

#### Implementation Pattern:
```python
# views.py - EventViewSet.perform_create()
def perform_create(self, serializer):
    user = self.request.user
    club = None
    
    if user.user_type == 'club_organizer':
        # Path 1: Get club from ClubOrganizer profile
        club_organizer_profile = getattr(user, "club_organizer_profile", None)
        if club_organizer_profile and club_organizer_profile.club:
            club = club_organizer_profile.club
        
        # Path 2: Check if this user is a Student who is a club head
        if not club:
            student_profile = getattr(user, "student_profile", None)
            if student_profile:
                club = Club.objects.filter(club_head=student_profile).first()
        
        # Path 3: Check if this user is a Student who is a club member
        if not club:
            student_profile = getattr(user, "student_profile", None)
            if student_profile:
                club_member = ClubMember.objects.filter(
                    student=student_profile, is_active=True
                ).first()
                if club_member:
                    club = club_member.club
        
        if club:
            event = serializer.save(club=club, created_by=user)
```

---

### 7. **Event to Hall Booking Integration (MEDIUM)**

**SRS Reference:** Section 2.2.2 & 2.2.3 - Event and Hall Booking Integration  
**Status:** ✅ FIXED

#### Problem:
- Hall booking and events were loosely coupled
- No validation that booking dates match event dates
- Could book hall for events that aren't yet confirmed
- Created audit trail entries without event context

#### Solution Implemented:
- Made event mandatory in hall booking (see Discrepancy #3)
- Enhanced perform_create() to log event information in audit trail
- Event name now included in hall booking serializer output
- Enables audit trail queries like "all bookings for event X"

#### Changes:
```python
# views.py - HallBookingViewSet.perform_create()
def perform_create(self, serializer):
    user = self.request.user
    club_member = ClubMember.objects.filter(student__user=user).first() \
        if user.user_type == 'club_organizer' else None
    event_id = self.request.data.get('event')
    
    instance = serializer.save(booked_by=club_member)
    
    # Log the action with event information
    event = Event.objects.get(id=event_id) if event_id else None
    event_info = f" for event '{event.name}'" if event else ""
    log_action(user, f"Requested hall booking for {instance.hall.name}{event_info}")
```

---

## Summary of Model Changes

### Event Model
```python
class Event(models.Model):
    # ... existing fields ...
    
    # NEW: Support multi-day events
    end_date = models.DateField(
        blank=True, null=True,
        help_text="End date for multi-day events. If blank, same as event_date."
    )
    
    # NEW: AICTE points at event creation
    aicte_activity_points = models.IntegerField(
        blank=True, null=True,
        help_text="Activity points allocated for participating in this event."
    )
    
    # NEW: Link to AICTE category
    aicte_category = models.ForeignKey(
        AICTECategory, on_delete=models.SET_NULL,
        null=True, blank=True, related_name='events',
        help_text="AICTE category for this event's points."
    )
    
    # NEW: Validation method
    def clean(self):
        if self.end_date and self.end_date < self.event_date:
            raise ValidationError("End date cannot be before start date.")
```

### HallBooking Model
```python
class HallBooking(models.Model):
    # MODIFIED: event is now REQUIRED (not optional)
    event = models.ForeignKey(
        'Event', on_delete=models.CASCADE,
        related_name='hall_bookings',
        help_text="Event for which the hall is being booked."
        # Removed: blank=True, null=True
    )
    # ... rest of fields unchanged ...
```

---

## Summary of Serializer Changes

### EventSerializer
- Added `end_date` field
- Added `aicte_activity_points` field
- Added `aicte_category` field
- Added `aicte_category_name` (read-only)
- Added comprehensive validation for:
  - End date >= start date
  - Activity points within category limits

### HallBookingSerializer
- Added `event_name` field (read-only) for better clarity
- Maintained all existing fields

---

## Summary of View Changes

### New Endpoint: AdminClubCreationView
- **Path:** `/api/admin/clubs/create/`
- **Method:** POST
- **Permission:** Admin only
- **Purpose:** Create clubs with faculty coordinator and club head assignments

### Enhanced: HallBookingViewSet.create()
- Added event_id validation
- Added event existence check
- Improved error messages

### Enhanced: HallBookingViewSet.perform_create()
- Now logs event name in audit trail
- Better traceability for bookings

---

## Migration

**File:** `0004_event_multi_day_and_points.py`

Includes:
1. Add `end_date` field to Event
2. Add `aicte_activity_points` field to Event
3. Add `aicte_category` field to Event (ForeignKey)
4. Modify `event` field in HallBooking (remove blank=True, null=True)

---

## Testing Recommendations

### 1. Event Creation Tests
```python
# Test single-day event
POST /api/events/
{
    "club": 1,
    "name": "Workshop",
    "event_date": "2025-12-01",
    "start_time": "10:00:00",
    "end_time": "12:00:00",
    "aicte_activity_points": 5,
    "aicte_category": 1
}

# Test multi-day event
POST /api/events/
{
    "club": 1,
    "name": "Conference",
    "event_date": "2025-12-01",
    "end_date": "2025-12-03",
    "start_time": "09:00:00",
    "end_time": "17:00:00",
    "aicte_activity_points": 10,
    "aicte_category": 1
}

# Test invalid end date (should fail)
POST /api/events/
{
    "event_date": "2025-12-05",
    "end_date": "2025-12-01"  // Should error
}

# Test invalid activity points (should fail)
POST /api/events/
{
    "aicte_activity_points": 100,  // If category max is 50
    "aicte_category": 1
}
```

### 2. Hall Booking Tests
```python
# Test booking without event (should fail)
POST /api/hall-bookings/
{
    "hall": 1,
    "booking_date": "2025-12-01",
    "start_time": "10:00:00",
    "end_time": "12:00:00"
}
// Expected: 400 - "Event is required when booking a hall."

# Test booking with event (should succeed)
POST /api/hall-bookings/
{
    "hall": 1,
    "event": 1,
    "booking_date": "2025-12-01",
    "start_time": "10:00:00",
    "end_time": "12:00:00"
}
// Expected: 201 - Booking created

# Test booking approval
POST /api/hall-bookings/1/approve/
// Only admin can approve, must have admin role
// Expected: 200 - "Hall booking approved."

# Test booking rejection
POST /api/hall-bookings/1/reject/
{
    "reason": "Room not available due to maintenance"
}
// Only admin can reject, must have admin role
// Expected: 200 - "Hall booking rejected."
```

### 3. Club Creation Tests
```python
# Test club creation by admin
POST /api/admin/clubs/create/
{
    "name": "Tech Club",
    "description": "Technology and innovation",
    "faculty_coordinator": 1,  // Mentor ID
    "club_head": 5              // Student ID
}
// Expected: 201 - Club created

# Test club creation by non-admin (should fail)
POST /api/admin/clubs/create/
{
    "name": "Tech Club",
    "faculty_coordinator": 1
}
// Expected: 403 - "Only administrators can create clubs."
```

### 4. Club Organizer Assignment
```python
# Register club organizer
POST /api/auth/register/
{
    "username": "john_doe",
    "email": "john@example.com",
    "password": "SecurePassword123",
    "user_type": "club_organizer"
}
// Expected: 201 - User created, profile created

# Admin assigns organizer to club
# (This happens via ClubMember creation or club_organizer_profile.club update)
POST /api/club-members/
{
    "club": 1,
    "student": 5,  // Student ID of the organizer (if also a student)
    "role": 1      // ClubRole ID (e.g., President)
}
```

---

## Backward Compatibility Notes

1. **Event.end_date:** Optional field - existing events will have NULL values
2. **Event.aicte_activity_points:** Optional field - points can be added later
3. **Event.aicte_category:** Optional field - can remain NULL
4. **HallBooking.event:** Now required - existing bookings with NULL event will need migration strategy:
   - Option A: Migrate existing bookings to associated events (if known)
   - Option B: Create dummy events for orphaned bookings
   - Option C: Delete orphaned bookings (if appropriate)

**Recommendation:** Run migration in staging first, assess impact of NULL event bookings, then handle migration strategy before production deployment.

---

## Documentation Updates Needed

1. **API Documentation:** Update swagger/OpenAPI docs for new fields
2. **Postman Collection:** Add new endpoints and examples
3. **Admin User Guide:** Document club creation workflow
4. **Developer Guide:** Document event multi-day and points feature
5. **Database Schema Diagram:** Update to show relationships

---

## Conclusion

All identified discrepancies between the SRS and implementation have been resolved:

✅ Event multi-day support added  
✅ Activity points at event creation added  
✅ Hall booking event selection made mandatory  
✅ Hall booking approval workflow clarified  
✅ Club creation workflow separated from organizer registration  
✅ Club organizer and club member relationships clarified  
✅ Event to hall booking integration improved  

The implementation now fully aligns with SRS Section 2.2 (Product Functions) and Section 2.3 (User Classes and Characteristics).
